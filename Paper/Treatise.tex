\input{preamble}

\begin{document}

\title{A JIT-less, Register-Mapped Static-ISA Virtual Machine for Many-Instance Applications}
\author{Matthew Sainsbury}
\date{\today}

% Cover Page
\begin{titlepage}
	\maketitle
\end{titlepage}

\pagenumbering{roman}

% Prefaces
\chapter*{Acknowledgements}
Kevin Naud√© for having the idea I guess

\chapter*{Abstract}
Traditional JIT-less high-level register virtual machines simulate virtual registers in random access memory (RAM) and load the virtual register from RAM whenever it is accessed~\citep{caseregistervm}. This treatise investigates an alternative approach where virtual registers are mapped to physical registers, and instructions are dispatched through token threading.\todo{really?} The token table is indexed not only on virtual opcodes, but also on the operands of the virtual instructions. To emulate a virtual instruction, the interpreter jumps to the appropriate code segment in the table based on the instruction word to be executed. This table grows in a polynomial fashion with increased virtual registers, and therefore the performance balance between table size and register pressure is investigated.

\chapter*{Declaration of Own Work}

\tableofcontents



% Main document body
\chapter{Introduction}
	\startrealnumbers
		
	\section{Background}
	Traditionally, the high level virtual machines implemented in interpreters are stack machines. Stack machines are used over register machines for a few reasons. Firstly, instructions for stack machines are smaller, because instruction operands are implicit. \todo{citations} This means that instruction fetching is faster. \todo{more reasons}
	
	On the other hand, register-based machines have some advantages over stack-based machines. For instance, many tasks can be performed in fewer register instructions than stack instructions. \citep{caseregistervm} However, register-based machines present their own problems. When executing a virtual machine operation, a register virtual machine must locate the virtual register in memory. 
	
	\section{Problem Description}
	Most real computers are register machines, \todo{cite?} so it seems natural that one would want to map virtual machine registers to physical ones. Unfortunately, because the ultimate purpose of a high level virtual machine is to be platform independent, virtual registers must be of a generalised structure. This typically results in virtual registers which are indexed. (eg., r0, r1, r2, ...) However, real register machines do not have indexable registers, and so it is difficult to map virtual registers to real registers.
	
	\section{Purpose and Scope}
	The goal of this project is to design and implement a high level register virtual machine based on the Lua 5.1 bytecode. This virtual machine will map some virtual machine registers to real registers. The virtual machine will perform dispatch not only on the opcodes of instructions, but on the entire instruction word including operands. The instruction word will be dispatched to a table of automatically generated assembly code for every combination of opcode and operands. The virtual machine will target the 64-bit AMD64 host machine architecture. \todo{or is it EM64T for intel?}
	
	
	
	\section{Overview of Treatise Structure}

% Optional
\chapter{Requirements Gathering}

% 10-12 pages
\chapter{Problem Exposition}
	\section{Literature Review}
	\cite{stackcaching} first wrote about this idea, but quickly dismissed it because it would ``cause code explosion, and will probably suffer a severe performance hit on machines with small first-level caches.'' He then went on to use the R4000 MIPS processor as an example, having 8 KB of L1 instruction cache.
	
	I believe that this approach deserves further investigation, especially with the advent of modern processors with significantly larger cache sizes---for example, 4th generation Intel Core processors, which have 32 KB of L1 instruction cache.\citep{haswellarch}
	
	\section{Difficulties}

% 10-12 pages
\chapter{Solution Design}

\chapter{Evaluation Methods and Results}

% Last chapter
\chapter{Conclusion}
	\section{Opportunities for Future Development}
	
	\section{Reflection}

% Bibliography
\bibliographysection

\end{document}